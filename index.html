<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>梵高粒子 - 多幅名作交互切换</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #video { position: absolute; top: 0; left: 0; width: 320px; height: 240px; opacity: 0.3; z-index: 10; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; z-index: 20; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
    <!-- MediaPipe Tasks Vision (最新版，手部检测) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="info">
        手掌张开：粒子流动星系模式（跟随手掌）<br>
        手掌握拳：切换到另一幅梵高名画<br>
        无手检测：保持当前画作形态
    </div>
    <video id="video" autoplay playsinline></video>
    <script type="module">
        // --------------------- 基本设置 ---------------------
        const PARTICLE_COUNT = 40000;
        const images = [
            // 星月夜 (The Starry Night)
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg/1280px-Van_Gogh_-_Starry_Night_-_Google_Art_Project.jpg",
            // 向日葵 (Sunflowers)
            "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Vincent_van_Gogh_-_Sunflowers_-_Google_Art_Project.jpg/1280px-Vincent_van_Gogh_-_Sunflowers_-_Google_Art_Project.jpg",
            // 麦田群鸦 (Wheatfield with Crows)
            "https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Vincent_van_Gogh_-_Wheat_Field_with_Crows_-_Google_Art_Project.jpg/1280px-Vincent_van_Gogh_-_Wheat_Field_with_Crows_-_Google_Art_Project.jpg",
            // 罗纳河上的星夜 (Starry Night Over the Rhone)
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/Starry_Night_Over_the_Rhone.jpg/1280px-Starry_Night_Over_the_Rhone.jpg"
        ];

        let currentImageIndex = 0;
        let positionsData = []; // 每个画作的粒子位置数组 (Float32Array)
        let colorsData = [];    // 每个画作的粒子颜色数组 (Float32Array)

        // --------------------- Three.js 初始化 ---------------------
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 800;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 1000;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
            positions[i * 3 + 2] = 0;
            colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
            sizes[i] = 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
                }
            `,
            transparent: true,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --------------------- 预加载图片并提取像素数据 ---------------------
        async function loadImageData(url) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = url;
            });

            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const data = ctx.getImageData(0, 0, img.width, img.height).data;

            // 下采样到 PARTICLE_COUNT 个点
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            const col = new Float32Array(PARTICLE_COUNT * 3);
            const aspect = img.width / img.height;
            const width = Math.sqrt(PARTICLE_COUNT * aspect) * 20;
            const height = width / aspect;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = Math.floor(Math.random() * img.width);
                const py = Math.floor(Math.random() * img.height);
                const idx = (py * img.width + px) * 4;

                pos[i * 3] = (px / img.width - 0.5) * width;
                pos[i * 3 + 1] = (0.5 - py / img.height) * height;
                pos[i * 3 + 2] = 0;

                col[i * 3] = data[idx] / 255;
                col[i * 3 + 1] = data[idx + 1] / 255;
                col[i * 3 + 2] = data[idx + 2] / 255;
            }
            return { pos, col };
        }

        async function preloadAll() {
            for (const url of images) {
                const { pos, col } = await loadImageData(url);
                positionsData.push(pos);
                colorsData.push(col);
            }
            // 初始化为第一幅画
            setImage(0);
        }

        function setImage(index) {
            currentImageIndex = index;
            const posAttr = geometry.getAttribute('position');
            const colAttr = geometry.getAttribute('color');
            posAttr.copyArray(positionsData[index]);
            colAttr.copyArray(colorsData[index]);
            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
        }

        // --------------------- MediaPipe Hand Landmarker ---------------------
        let handLandmarker;
        let lastHandClosed = false;
        let handCenter = new THREE.Vector2(0, 0);
        let handVisible = false;

        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });

            const video = document.getElementById('video');
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener('loadeddata', startDetection);
            });
        }

        function startDetection() {
            const video = document.getElementById('video');
            function detect() {
                const results = handLandmarker.detectForVideo(video, performance.now());
                processHands(results);
                requestAnimationFrame(detect);
            }
            detect();
        }

        function processHands(results) {
            handVisible = false;
            if (results.landmarks && results.landmarks.length > 0) {
                handVisible = true;
                // 取第一只手的手掌中心（大致为手腕到中指尖的平均）
                const landmarks = results.landmarks[0];
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                handCenter.x = (wrist.x - 0.5) * 2; // 归一化到 [-1,1]
                handCenter.y = -(middleTip.y - 0.5) * 2;

                // 判断握拳：中指尖到手腕距离 < 阈值
                const dx = landmarks[12].x - landmarks[0].x;
                const dy = landmarks[12].y - landmarks[0].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const isClosed = dist < 0.2; // 经验阈值

                // 边缘检测：上一帧张开 -> 本帧握拳
                if (!isClosed && lastHandClosed) {
                    // 切换到不同画作
                    let newIndex;
                    do {
                        newIndex = Math.floor(Math.random() * images.length);
                    } while (newIndex === currentImageIndex);
                    setImage(newIndex);
                }
                lastHandClosed = isClosed;
            } else {
                lastHandClosed = false;
            }
        }

        // --------------------- 动画循环 ---------------------
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const posAttr = geometry.getAttribute('position');
            const positions = posAttr.array;

            const targetPos = positionsData[currentImageIndex];
            const isOpenPalm = handVisible && !lastHandClosed; // 张开手掌

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let tx, ty, tz = 0;

                if (isOpenPalm) {
                    // 流动星系模式：受手掌吸引 + 噪声流动
                    tx = handCenter.x * 400 + (Math.sin(time + i * 0.01) * 100);
                    ty = handCenter.y * 400 + (Math.cos(time + i * 0.013) * 100);
                    // 额外噪声
                    tx += Math.sin(time * 2 + i * 0.02) * 50;
                    ty += Math.cos(time * 2 + i * 0.025) * 50;
                } else {
                    // 还原到画作位置
                    tx = targetPos[i3];
                    ty = targetPos[i3 + 1];
                }

                // 平滑插值
                positions[i3] += (tx - positions[i3]) * 0.05;
                positions[i3 + 1] += (ty - positions[i3 + 1]) * 0.05;
                positions[i3 + 2] += (tz - positions[i3 + 2]) * 0.05;
            }
            posAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --------------------- 启动 ---------------------
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        preloadAll().then(() => {
            initMediaPipe();
            animate();
        });
    </script>
</body>
</html>
